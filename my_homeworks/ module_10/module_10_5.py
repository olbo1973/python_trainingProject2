"""
Домашнее задание по теме "Многопроцессное программирование"
Задача "Многопроцессное считывание":
Дата: 03.01.2025 год.
"""

##  Был собран доработанный код, который включает чтение файлов и подсчет количества строк в них
# (и вывод этих данных в консоль):


import datetime  # Импортируем модуль для работы с датой и временем
from multiprocessing import Pool  # Импортируем класс Pool для многопроцессного выполнения
import os  # Импортируем модуль для работы с операционной системой

# Функция для чтения информации из файла
def read_info(name):
    all_data = []  # Создаем локальный список для хранения данных
    line_count = 0  # Счётчик строк
    with open(name, 'r', encoding='utf8') as file:  # Открываем файл для чтения с указанием кодировки
        for line in file:  # Читаем строки из файла
            all_data.append(line)  # Добавляем каждую считанную строку в список all_data
            line_count += 1  # Увеличиваем счётчик строк
    print(f'Файл: {os.path.basename(name)}, строки: {line_count}')  # Выводим имя файла и количество прочитанных строк
    # Файл автоматически закроется после завершения блока with, no need for file.close()

# Список файлов для чтения в формате 'file i.txt'
list_files = [f'./file {i}.txt' for i in range(1, 5)]

if __name__ == '__main__':  # Проверяем, что запускаем программу как основную
    # Линейный вызов (lin)
    start_lin = datetime.datetime.now()  # Начинаем замер времени линейного выполнения
    for files in list_files:  # Проходим по каждому файлу в списке
        read_info(files)  # Вызываем функцию read_info для каждого файла

    end_lin = datetime.datetime.now()  # Заканчиваем замер времени линейного выполнения
    print(f'Время выполнения: {end_lin - start_lin} (линейный)')  # Выводим время выполнения линейного вызова

    # Многопроцессный (mp)
    start_mp = datetime.datetime.now()  # Начинаем замер времени многопроцессного выполнения
    with Pool(processes=6) as pool:  # Создаем пул из 6 процессов
        pool.map(read_info, list_files)  # Параллельно вызываем функцию read_info для каждого файла
    end_mp = datetime.datetime.now()  # Заканчиваем замер времени многопроцессного выполнения
    print(f'Время выполнения: {end_mp - start_mp} (многопроцессный)')  # Выводим время выполнения многопроцессного вызова


## Комментарии:
# Использование `os`:
#     - Импортирован модуль `os` для работы с файловыми путями.